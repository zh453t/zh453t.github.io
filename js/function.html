<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>function</title>
  <link rel="stylesheet" href="lib/public.css">

</head>
<body>
  <h3>函数</h3>
  <progress></progress>
<strong>默认值：</strong>
原始：createBooking('LH123') // Object { flightNum: "LH123", numPassengers: undefined, price: undefined }
1. 短路
numPassengers = numPassengers || 1 // 如果np是undefined, 取1
2. es6+
(flightNum, numPassengers<b> = 1</b>, price)

一等函数：定义上，函数是对象。
高阶函数：实际上，返回值、参数其一为函数，或二者都满足。
return myFunction() 
function(anotherFunction) {}
<samp>const oneword = (str) => {
  return str.replace(/ /g, '').toLowerCase()
}

const upperFirstWord = function(str) {
  const [first, ...others] = str.split(' ')
  console.log(first, others)
  return [first.toUpperCase(), ...others].join(' ')
}

const transformer = function(str, fn) { //<strong>参数为函数，使用了另一函数</strong>
  console.log(`transformed string: ${fn(str)}`)
  console.log(`Transformed by: ${fn.name}`)
}</samp>

返回其他函数
<samp>
const greet = function(greeting) {
  return function(name) {
    console.log(`${greeting} ${name}`)
  }
}
const greeterHey = greet('Hey') // 返回了一个函数。
greeterHey('X') // Hey X
greet('hey')('windows') // hey windows

const greet = (greeting) =>  (name) => console.log(`${greeting} ${name}`)</samp>
<h3>this关键字</h3>
<samp>const lufthansa = {
  airline: 'lufthansa',
  iataCode: 'LH',
  bookings: [],
  book(flightNum, name) {
    console.log(`${name} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}`)
    this.bookings.push({
      flight: `${this.iataCode}${flightNum}`,
      name
    })
  }
}

const eurowings = {
  name: 'eurowings',
  iataCode: 'EW',
  bookings: [],
}
const book = lufthansa.book</samp>
<b>book(23, 'Sarah Williams')</b> // Uncaught TypeError: can't access property "airline", this is undefined
// 此时, this指向undefined.

如何指定this是谁?
<b>.call()</b>
(this指定对象, 参数...)
book.call(eurowings, 23, 'Sarah Williams')
book.call(lufthansa, 265, 'John Smith')
.call()绑定this关键字并立即执行函数。

<b>.apply()</b>
(this指定对象, [参数])
同上，参数为数组。
book.apply(eurowings, [23, 'Sarah Williams'])
book.apply(lufthansa, [265, 'John Smith'])

<b>.bind()</b>
捆绑
不会立即执行。
(this, 参数[按顺序]) 

const bookEW = book.bind(eurowings)
const bookEW23 = book.bind(eurowings, 23)
bookEW23('Martha')
<button>buy</button>

在事件监听器上：
document.querySelector('button').addEventListener('click', lufthansa.buyPlane)
//&lt;button> NaN
this会指向元素本身

由于不是立即执行函数，所以需用.bind()
addEventListener('click', lufthansa.buyPlane.bind(lufthansa))

<!-- const addTax = (rate, value) => value + value * rate

const addTaxRate = function (rate) {
  return function (value) {
    return addTax(value, rate)
  }
}
 -->
<samp>
const poll = {
  question: 'what is your favorite language?',
  options: [
    '0: Javascript',
    '1: python',
    '2: C++',
    '3: Rust'
  ],
  answers: new Array(4).fill(0) 
}

// 3
poll.displayResults = function(type = 'array') {
  if (type == 'string') console.log(`Poll results are ${this.answers.join()}`)
  if (type == 'array') console.log(this.answers)
}

// 1
poll.registerNewAnswer = function() {
  const input = parseInt(prompt(`
  what is your favorite language?
    '0: Javascript'
    '1: python'
    '2: C++'
    '3: Rust'
  `))
  if (input < 4 && input > -1) this.answers[input]++
  else console.warn('input invalid')
  console.log(poll.answers)
  return this.displayResults('string')
}

//2
document.querySelector('button').addEventListener('click', poll.registerNewAnswer.bind(poll))

poll.displayResults.call({answers: [1, 2, 3, 4]})
</samp>

<h4>立即调用</h4>
只使用一次
(function() {
  console.log('This will never run again')
}) <b>()</b>
调用|
上一行需要加; 不然会报错.  Uncaught TypeError: "use strict" is not a function


<b>闭包</b> Closures
闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。
<samp>const secureBooking = function() {
  let passengerCount = 0;

  return function() {
    passengerCount++
    console.log(passengerCount)
  }
}

const booker = secureBooking()
booker()
booker()
booker()</samp>
现在, 全局作用域有secureBooking, booker两个函数
 - secureBooking 有 passengerCount 变量, 和继承全局的两个函数
 - booker 只有继承的

--正在调用栈中执行的函数还调用了其他函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。
--当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。

booker执行, 进入调用栈, 没有变量, [empty]
执行时调用了 secureBooking, 它进入调用栈, 带着passengerCount
secureBooking 执行结束, 返回了一个函数。 secureBooking 被清出

按常理, secureBooking 返回的函数不应该被 booker 访问到

由于闭包机制, booker 被调用时, 可以访问它调用的 secureBooking 的变量环境
闭包会把与之关联的

所以连续调用3次 booker, passengerCount 1->3

闭包在何时发生?
<samp>let f
const g = function() {
  const a = 23
  f = function() {
    console.log(a * 2)
  }
}

const h   = function() {
  const b = 666
  f = function() {
    console.log(b * 2)
    console.log(a * 2)
  }
}
g() // 此时, f变成function
f() // 46 此时, f仍能访问a
h() // f变成h的function
f() // 1332
// ReferenceError: a is not defined
// 新的闭包代替了旧的

// 回调
const boardPassengers = function(n,wait) {
  const perGroup = n / 3
  setTimeout(function() {
     console.log(`We are boarding ${n} passengers`)
    console.log(`There are 3 groups, each ${perGroup} passengers.`)
  }, wait * 1000)
  console.log(`We will start boarding in ${wait}s`)
}
</samp>
<h1>hello</h1>

(function() {
  const header = document.querySelector('h1')
  header.style.color = 'red'
  document.querySelector('body').addEventListener('click', function() {
    header.style.color = 'blue'
  })
})();

<script src="lib/public.js"></script>
</body>
</html>