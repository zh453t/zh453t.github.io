
<!DOCTYPE html>
<html>
<head>
    <title>note</title>
    <meta charset="UTF-8">
    <style>
        body {
            background-color: #f3f3f3;
            padding-left: 120px;
            padding-top: 1em;
			line-height: 1.4;
			margin: 0;
        }
        details {
            white-space: pre-wrap;
			word-wrap: break-word;
            font-family: Cascadia Code, Consolas, Microsoft JhengHei, monospace;
            margin-block: 1em;
        }
		details details {
			margin-block: 0;
			margin-left: 2em;
		}

        h5 {
            font-size: large;
            margin-block: 8px 0;
            color: rgb(45, 165, 180);
        }
        summary {
            font-weight: bold;
            font-size: x-large;
            color: rgb(45, 165, 180);
            cursor: cell;
        }
		details details summary {
			font-size: 1.2em;
		}
        b {color: rgb(165, 57, 53);}
		.examples article  {
			display: flex;
			justify-content: space-around;
			gap: 1em;
			max-width: 85%;
		}
		.examples figcaption {font-weight: bold;}
		samp {
			display: block;
			font-family: inherit;
			background-color: #efefef;
			padding: 0 1.4em 1em;
			width: fit-content;
			border: 1px dashed #abc;
			max-width: 80%;
		}
		.examples samp {flex: 1}
    </style>
</head>
<body>
<details hidden><summary>循环</summary>
    while (i &lt;= 5) {
        console.log(i)
        i++
        if (i == 3) {
            i++
            continue
        }
    }
<b>a ? a : b 表达式 ? true时执行代码 : false时执行代码</b>
var sum = 0
for (var i = 1; i &lt;= 100; i++) {
    sum += i
}
sum = sum / (i - 1)
alert(sum)

<b>1-100奇数和与偶数和</b>
var even = 0
var odd = 0
for (let i = 1; i &lt;= 100; i++) {
    // if (i % 2 == 0) {
    //     even += i
    // } else {
    //     odd += i
    // } //低效
    i % 2 == 0 ? even += i : odd += i //高效
}
console.log(even)
console.log(odd)

步增3 
var sum = 0;
for (var i = 0; i &lt; 100; i += 3) {
    sum += i
}
console.log(sum);
<h5>while循环</h5>
<b>while (condition) {
只要条件为true一直执行
}</b>


<b>求学生成绩</b>

var num = parseInt(prompt('学生人数')) // 弹窗输人数
var score = 0
for (let i = 1; i &lt;= num; i++) {
    score += parseFloat(prompt(`请输入' ${i} '的成绩`)) // `字符串${变量}字符串` = '字符串' + i + '字符串'
}
score / num // score ==> average score
console.log(score)
<h5>continue 跳出循环 break 结束循环</h5>
let num = 1
while (num &LeftDownTeeVector; 5) {
    if (num == 3) {
        num++
        continue // 结束本次循环进入下次循环
        break // 跳出循环
    }
    num++
    console.log(num)
}
<h5>atm</h5>
var money = 0
while (true) { // 无限循环
    let command = prompt('请选择您的操作\n1. 存款\n2. 取款\n3. 查看余额\n4. 退出')
    switch (command) {
        case '1': money += parseInt(prompt('存多少'))
            break
        case '2': money -= parseInt(prompt('取多少'))
            break
        case '3': alert(`你的存款有${money}元`)
            break
        case '4': break
            break
    }
}
<h5>tipCalc</h5>
const bill = parseFloat(prompt('hello'))
const tip = bill >= 50 && bill &lt;= 200 ? bill * 0.15 : bill * 0.2 // 三元表达式作为表达式可以直接给量赋
console.log(`The bill was ${bill}, the tip was ${tip}, and the total value was ${bill + tip}`);
'use strict';
function add(a, b) {
    return a + b // return 输出
}
console.log(add(5,6))
<!-- 2022-11-19 -->
<h5>再谈for循环</h5>
<b>for循环遍历数组</b>
遍历整个数组
const ymd = [2022, 11, 20]
const types = []
for (let i = 0; i &lt; ymd.length; i++) {
    console.log(ymd[i])
    types[i] = typeof ymd[i] // 记录到另一个数组⭐
}
console.log(types);
<b>重构</b>
function calcTip(bill) {
    let tip = null
    if (50 &lt; bill && bill &lt; 300) {
        tip = bill * 0.15
    } else if (bill > 0) {
        tip = bill * 0.2
    } else { return 'error: bill &lt; 0' }
    return tip
}
console.log(calcTip(100))
let bills = [126, 780, 502]
let tips = []
for (let i = 0; i &lt; bills.length; i++) {
    tips.push(calcTip(bills[i]))
}
console.log(tips); // 暂无循环遍历🤔 现在有了🥰

<b>break和continue</b>
const numbers = [1, 2, 3, 4, 5]
const odds = []
for (let i = 0; i &lt;= numbers.length; i++) {
    if (numbers[i] % 2 == 0) {
        continue
    } else {
        odds[i] = numbers[i];
    }
}
console.log(odds)

<b>-- & for{for{}}</b>
for (let i = numbers.length - 1; i >= 0; i--) {
    console.log(numbers[i])
}
for (let exercise = 1; exercise &lt; 4; exercise++) {
    console.log(`-------- Starting Exercise ${exercise}`);
    for (let rep = 1; rep &lt;= 5; rep++) {
        console.log(`Exercise ${exercise}: lifting repetition ${rep}`);
    } // 循环套循环
}

<b>while</b>
let rep = 1
while (rep &lt;= 10) {
    console.log(`lifting repetition ${rep}`)
    rep++
}

let dice = Math.trunc(Math.random() * 6) + 1
while (dice !== 6) {
    console.log(`You rolled a ${dice}`);
    dice = Math.trunc(Math.random() * 6) + 1
    if (dice==6) console.log('Loop is about to end...') // 写在一行if可以不用{} 
}
// <b>while适合用在不限次数的循环</b>

const bills = [22, 321, 126, 195, 85, 20, 49, 378, 491, 1000];
function calcTip(bill) {
  let tip = 0;
  if (50 &lt; bill && bill &lt; 300) {
    tip = bill * 0.15;
  } else if (bill > 0) {
    tip = bill * 0.2;
  } else {
    return 'error: bill &lt; 0';
  }
  return tip;
}
let total = [];
for (let i = 0; i &lt; bills.length; i++) {
  // tips[i] = calcTip(bills[i]), or
  tips.push(calcTip(bills[i]));
  total.push(tips[i] + bills[i]);
}
console.log(tips);
console.log(total);

function calcAverage(arr) {
  let sum = 0;
  for (let i = 0; i &lt; arr.length; i++) {
    sum += arr[i];
  }
  sum /= arr.length; // ???居然真有这个除等
  return sum;
}
console.log(calcAverage(bills));
</details>

<details hidden><summary>Function</summary>
<b>function expression</b>
const t = function (num) {
    return num + 2
}
<b>function declaration</b>
function t(num) {
    return num + 2
}

<b>arrow function</b>
const numplus = num => num + 2
// == function (num) {return num + 2}
// 函数变量 => 返回值
const num = numplus(1)
const age = age => {
    const birth = 2022 - age
    const hund = birth + 100
    return birth
}
// 函数调用函数
function cutFruitPieces(fruit) {
    return fruit * 4
}
function fruitProcessor(apple, orange) {
    const applePieces = cutFruitPieces(apple)
    const orangePieces = cutFruitPieces(orange)
    const juice = `Juice with ${applePieces} apple pieces and ${orangePieces} orange pieces.`
    return juice
}
console.log(fruitProcessor(1,2))

<b>function 案例</b>
const calcAverage = (a, b, c) => (a + b + c) / 3
function checkWinner(team1, score1, team2, score2) {
    if (score1 / score2 >= 2) {
        return `${team1} wins (${score1} vs. ${score2})`
    } else if (score2 / score1 >= 2) {
        return `${team2} wins (${score2} vs. ${score1})` // 低效？
    } else {
        return 'No team wins.'
    }
}


const avgDophins = calcAverage(98, 23, 71)
const avgKoalas = calcAverage(65, 54, 49)
console.log(checkWinner('Dophins', avgDophins, 'Koalas', avgKoalas));
</details>
<details hidden><summary>Array 数组</summary>
    // 两种声明方法
    const friend = ['Michael', 'Steven', 'Jerry']
    const numbers = new Array(1, 2, 3)
    // 提取
    console.log(friend[0]); // name 第一项 ==> Michael
    console.log(friend.length); // 项数
    console.log(friend[friend.length - 1]); // 最后一个

    friend[2] = 'Jay' // 找到第(2+1)==>第三项，赋值为Jay
    console.log(friend[2])

    // friend = ['Hello', 'Hello'] // x 不能完全替换

    // 套娃
    const arr = ['Hello', friend]
    console.log(arr.length); // 1 + 1 = 2

    // console.log(numbers - 1); // 加减乘除不适用
    // 不过可以这样
    const add1 = a => a + 1
    const num1 = [add1(numbers[0]), add1(numbers[1]), add1(numbers[2])]
    <h5>操作</h5>

    <h5>添加</h5>
    nums.push(4) // <b>push() 插入到数组最后</b>
    const newLength = nums.push(5) // 返回新数组的长度

    nums.unshift(1) // <b>unshift() 在前面插入</b>
    console.log(nums);
    console.log(nums.unshift(2)); // 也是返回新数组长度

    <h5>删除</h5>
    const popped = nums.pop() // pop() 移除最后一项
    console.log(nums);
    console.log(popped); // 返回新数组长度

    const shifted = nums.shift() // 删除第一个
    console.log(shifted) // 返回新数组长度

    <h5>查询</h5>
    console.log(nums.indexOf(3)); // <b>indexOf(数组某一项) 查询在数组的位置(0,1,2,3...)</b>
    console.log(nums.indexOf('what')); // 没有的话返回-1

    console.log(nums.includes('what')); // <b>includes(value) 查询数组里面有没有这项 有true 没有false</b>
    console.log(nums.includes(1)) // true

    <b>案例 tipCalc+</b>
    function calcTip(bill) {
        let tip = null
        if (50 &lt; bill && bill &lt; 300) {
            tip = bill * 0.15
        } else if (bill > 0) {
            tip = bill * 0.2
        } else { return 'error: bill &lt; 0' }
        return tip
    }
    console.log(calcTip(100))
    let bills = [126, 780, 502]
    let tips = [calcTip(bills[0]), calcTip(bills[1]), calcTip(bills[2])]
    console.log(tips); // 暂无循环遍历🤔

    const 数组可以换行!🥰 = [
    'on',
    19,
    undefined,
    false
]
</details>
<details hidden><summary>Objects 对象</summary>
<h5>数组也是一种对象，特殊的</h5>
<b>基本结构</b>
const today = {
    year: 2022, // 每一个都是一个property
    month: 11,
    date: 19 
}
<h5>如何访问</h5>
console.log(today.date) // dot
console.log(today['date']) // bracket
console.log(today['da' + 'te']); // bracket可以组合 dot不行

// <b>直接加</b>
today.isWeekend = true


const today = {
    year: 2022,
    month: 11,
    date: 19,
    // daysLeft: date => 30 - date // function也是值😄
    daysLeftCalc: function() {
        console.log(this) // <b>this 指谁在调用这个函数</b>
        return 30 - this.date
        // this.daysLeft = 30 - this.date // 你甚至<b>可以加一个property</b>
        // return this.daysLeft
    },
    getReport: function() {
        return `今天是${this.year}年${this.month}月${this.date}日，距离月底还有${this.daysLeftCalc()}天`
    },
}
// today.daysLeft(today.date)
console.log(today.daysLeftCalc()) // this是today
console.log(today.getReport());

<h5>案例</h5>
const Mark = {
    fullName: 'Mark Miller',
    weight: 78,
    height: 1.69,
    calcBMI: function () {
        this.BMI = this.weight / (this.height ** 2)
        return this.BMI
    }
}
const John = {
    fullName: 'John Smith',
    weight: 92,
    height: 1.95,
    calcBMI: function () {
        this.BMI = this.weight / (this.height ** 2)
        return this.BMI
    }
}
Mark.calcBMI() > John.calcBMI()?
console.log(`${Mark.fullName}'s BMI (${Mark.BMI}) is higher than ${John.fullName}'s BMI (${John.BMI})!`):
console.log(` ${John.fullName}'s' BMI (${John.BMI}) is higher than ${Mark.fullName}'s BMI (${Mark.BMI})!`);

</details>
<details hidden><summary>DOM</summary>
document dom的入口
console.log(document) ==> document其实是一个对象，里面有众多函数
<b>querySelector => 选择器 访问特定标签的</b>会返回第一个符合要求的元素
<b>选择全部要求的元素 => querySelectorAll</b>会返回一个nodelist 类似于数组

document.querySelector('.main')

    &lt;p class="main">true&lt;/p>
	&lt;script>
      'use strict'
      document.querySelector('.main').textContent = 'false'
    &lt;/script>
	
<b>script 要在元素加载完之后才能访问</b>


<b>addEventListener(监听什么, 监听到执行的操作)</b>
例：	document.querySelector('button').addEventListener('click', <i style="color:purple" title="芝士给eventlistner函数的一个值 只不过这个值也是个函数">function() {
	console.log('You clicked the button! 😃')
	}</i>) // 点击button 会log一条消息
	
<b>classList 元素的class列表</b> 返回一个叫DOMTokenList的东西 类似于数组
	add('class') remove('class') 不加点 代替数组的push shift
	
<h5>检测按键</h5>
addEventListener('keydown') // 在按下某个键的时候
'keyup' 放开的时候
'keypress' 连续按某个键的时候

document.addEventListener('keydown', function(e) { // 在function这里设定一个参数
	console.log('You pressed the key')
	console.log(e) // 它是一个object keydown { target: body, key: "d", charCode: 0, keyCode: 68 }
	console.log(e.key) // 按键是什么
	
</details>
<details hidden><summary>案例</summary>
	<samp>
    const temps = [3, 2, 6, -1, 'error', 16, 19, 7]
    // 计算temps的最大差值
    function calcAmplitude(temp1,temp2) {
      let temps = temp1.concat(temp2) // mdn
      let max = temps[0]
      let min = temps[0]
      for (let i = 0; i &lt; temps.length; i++) {
        if ((temps[i] == 'error')) continue
        if (temps[i] > max) max = temps[i]
        if (temps[i] &lt; min) min = temps[i]
      }
      return max - min
    }
    console.log(calcAmplitude(temps,[0,2,32]))
    // 收到2个数组
    // 如何把数组组合在一起？Merge 2 arrays ==> concat
	</samp>
    <h5>debug</h5>
    function measureKelvin() {
        const measurement = {
          type: 'temp',
          unit: 'celsius',
          value: parseFloat(prompt('degrees celsius:')) // bug在此
        }
        debugger // 浏览器执行到这里的时候打开debugger
        const kelvin = measurement.value + 273
        return kelvin
      } 
      console.log(measureKelvin());
      console.error(''); // 向控制台报错
      console.warn(''); // 警告



      const arr1 = [17, 21, 23]
      const arr2 = [12, 5, -5, 0, 4]
      // <b>disaplay a string with these temperatures 天气预报生成器</b>
      // 1. 生成每天的
      // 2. 组合一下
      function printForcast(inputarr) {
        let outputarr = []
        for (let i = 0; i &lt; inputarr.length; i++) {
          i == 0
            ? (outputarr[i] = `${inputarr[i]} °C in ${i + 1} day`)
            : (outputarr[i] = `${inputarr[i]} °C in ${i + 1} days`) // 单复数问题😅
          // debugger
        } // 创建单个句子

        let outputstr = ''
        for (let i = 0; i &lt; outputarr.length - 1; i++) {
          outputarr[i] += ' ... ' // 加间隙
          outputstr += outputarr[i] // 加字符串
        } // 将多天的句子组合在一起
        outputstr += outputarr[outputarr.length - 1]
        return outputstr
      }
      console.log(printForcast(arr1))
      console.warn(printForcast(arr2));
</details>
<details hidden><summary>javascript 基础及原理</summary>
js即时编译 在engine里操作
分为call stack 和 heap

<b>Call stack</b> 调用栈
调用的函数在这里处理 处理完清理掉
<b>heap</b> 堆

<b>compile</b> 编译 ==> complication
<b>interpret</b> 解释 ==> interpretation 及时解释
js是两种混合 just-in-time complication 中间还有machine code 但不生成文件

js runtime js执行环境 == Engine + 一堆api + 调用栈里的Callback queue

<b>编译后，执行顺序</b>
const greetings = 'hello' // 先创建global execution context => top-level code (不包含在任何函数中的code) 
		<b>execution context</b>: 代码执行的环境，存储了代码执行的必要信息
2. [execute] function里的code, 等待被调用
    => 例如onclick事件是等待click的时候执行 const a.onclick = () => {....} // .... 会后被执行

<samp>
<b>Execution Context</b>里面有
1. variable 变量 (包括let const, functions, 'arguments object')
2. <b>scope</b> chain 
3. <b>this</b> keyword // 箭头函数很特殊
</samp>

<details><summary>作用域scope 和 scope chain</summary>
scope 分3种
1. Global Scope
2. 函数作用域 => function 里的, var const let 都不能在外使用
3. block scope (ES6) => if, switch等, const和let不能在外使用, 但var可以在同级, strict mode下function 也是这种

你可以访问上面的和自己的函数 但不能访问其他的
<b>案例</b>
<samp>
const day = 29
function first() {
	const year = 2022
	const month = 11
	if (month > 10) {
		var winter = true
		const summer = false
	}
	
	function second() {
		const weather = 'cold'
		console.log(`today is ${year} ${month} ${day}, is it winter? ${winter} or it's summer? ${summer}: the weather is ${weather}`) // summer is not defined: <b>const 和 let 不能跨block作用域使用</b>
	}
	second()
}
first()
</samp>
global scope: day = 29
first(): year, month, |day|, if里var的winter
if (...): |year|, |month|, ||day||, summer, `winter`
second(): |year|, |month|, ||day|| if里var的winter
<hr color="#444">
scope chain vs. call stack

<b>函数只作用在{}里面 var特殊</b>
<b>案例2: </b>
calcAge(1989) // missing variable name
function calcAge(birthYear) {
	const age = 2037 - birthYear
	console.log(name) // 在 i函数里面没有找到，找全局函数找到了
	
	function printAge() {
		const output = `You are ${age}` // output 仅限printAge里面
		console.log(output)
		if (age > 50) {
			const old = true
			console.log(old) // old仅限if里面
		}
		// console.log(old)
		console.log(birthYear) // 在上一级找
	} // 这个funciton仅限calcAge里面
	printAge()
	return age
}
const name = 'hong'
calcAge(1909)
// printAge()

<b>全局的var会在window下创造一个属性 变量名: 值</b>
var isSaturday = false
console.log(window.isSaturday) // false
</details>
<details><summary>hoisting 变量提升</summary>
在同一个{}中，先用后声明变量会...
let => 报错
const => 报错
var => undefined (var提升到了最前 但后面的值没有 只有一个壳 所以是undefined)
function funcDec() =>

<figure class="examples"><figcaption>先声明函数后用的三种情况</figcaption>
<article>
<samp>
<b>表达式</b>
console.log(add(2,4))
function add(a,b) {
	return a + b
} 可以
</samp><samp>
<b>变量</b>
console.log(add(2,4))
const add = function (a,b) {
	return a + b
}
<b>Uncaught ReferenceError: can't access lexical declaration 'add' before initialization</b>
</samp>
<samp>
<b>箭头</b>
console.log(add(1,2))
const add = (a,b) => a + b
<b>Uncaught ReferenceError: can't access lexical declaration 'add' before initialization</b>
</samp>
</article>
</figure>
</details>
<details><summary><i>this</i></summary>
<b>在常规函数中, this 指的是调用这个函数的object等</b>
<samp>
const date = {
  year: 2022,
  month: 12,
  date: 6,
  log: function() {console.log(this.year)}
}
date.log() // this = date
</samp>
<figure class="examples">
<figcaption>几种this特殊情况：</figcaption>
<article>
<samp>
<b>1. 直接调</b>
'strict mode'
function logThis() {
  console.log(this)
}
logThis() // undefined
// 不用strict mode的话会返回window

loglog.log = date.log
console.log(loglog) // this 是不断变化的

const aLogFunc = date.log
aLogFunc() // undefined 直接调没用
</samp>
<samp>
<b>2. 箭头函数</b>
const logThis () => {console.log(this)}
logThis() // undefined
</samp>
<samp>
<b>3. Event listener</b>
function logThis() {
  console.log(this)
}
document.querySelector('button').addEventListener('click', logThis) // 返回button
</samp>
</article></figure>
<b>object里面</b>.
<samp>
logday: function() {
	const day = 1
	logday()
},
log: () => {console.log(this.year)}
}
date.logday() // Uncaught ReferenceError: logday is not defined
</samp>

<figure class="examples">
<figcaption>函数里的函数没有this</figcaption>
<article>
<samp>
<b>问题</b>

const date = {
year: 2022,
month: 12,
date: 6,
log: function() {
	this.day = 1
	const logAll = function () {
		console.log(this.year, this.month, this.date)
	}
	logAll()
	// Uncaught TypeError: can't access property "year", this is undefined
}
date.log()
</samp>
<samp>
<b>解决方案1</b>
设self = this
const date = {
    year: 2022,
    month: 12,
    date: 6,
    log: function() {
        const self = this
        const logAll = function () {
            console.log(self.year, self.month, self.date)
        }
        logAll()
        // 2022 12 6
    }
    date.log()
</samp>
<samp>
<b>方案2：直接用箭头的<del>bug</del>特性</b>
箭头的this都是指所在父级
const date = {
    year: 2022,
    month: 12,
    date: 6,
    log: () => {
        const logAll = function () {
            console.log(this.year, this.month, this.date)
        }
        logAll()
        // 2022 12 6
    }
    date.log()
</samp>
</article></figure>
<b>arguments：函数输入的变量</b>
<figure class="examples"><figcaption><b>arguments只在普通函数存在，箭头不存在</b></figcaption>
<article>
<samp>
const add = function (a,b) {
    console.log(arguments)
}
add(12,13,11,2)
返回object: Arguments { 0: 12, 1: 13, 2: 11, 3: 2 … }
</samp>
<samp>
const add = (a,b) => {
    console.log(arguments)
}
add(12,13,11,2)
// <b>Uncaught ReferenceError: arguments is not defined</b>
</samp>
</article>
</figure>
</details>
<details open><summary>Primitives & Objects</summary>
<b>object {} []</b>
<b>Primitives => number, string, boolean 一切不是object 的成绩</b>
<figure class="examples"><figcaption>二者复制更新的区别</figcaption>
<article>
<samp>
1   let age = 30
2   let oldage = age
3   age = 31
4   console.log(age)
5   console.log(oldage)

为甚？
            Call Stack 里面：
    identifier  address     value <b>不可修改</b>
1   age         0001(as if) 30
2   age, oldage 0001        30

3   oldage      0001        30
    age         0002        31
</samp>
<samp>
const today = {
	year: 2022,
	month: 12,
	date: 7
}
let newday = today
today.date = 8
console.log(today.date)
console.log(newday.date)

object存在heap里，在call stack中指向heap的地址
调用栈里面：
    identifier    address     value
1   today         0001        D2FF (heap中地址)
2   newday        0001        D2FF
堆 里面：
    address     value
1   D2FF        {year: 2022, ... , date: 7}
2   D2FF        {year: 2022, ... , date: 8}
</samp>
</article></figure>
怎么办？
<samp>
const today = {
	year: 2022,
	month: 12,
	date: 7
}
const newday = Object.assign({}, today) // Object.assign <b>把多个object整合到一起 但是只能复制第一层的，里面的object还是原来的地址</b>
today.date = 8
console.log(newday) <b>浅拷贝</b>
</samp>
</details>
</details>

<details open><summary>现代js</summary>

<details><summary>数组与对象</summary>
<details><summary>1.数组</summary>
<samp>
    const arr = [2,3,4]
    let [a,b,c] = arr
    console.log(a,b,c) <b>快捷访问数组：建立对应的变量</b>
    // a=2 b=3 c=4
    <b>跳过的话直接空过去</b>
    let [e,,f] = arr
    // e=2. f=4
</samp>
<details><summary>案例</summary>
<samp>
const restaurant = {
    name: 'Classico Italiano',
    location: ',,, Firenze, Italy',
    categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],
    starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
    mainMenu: ['Pizza', 'Pasta', 'Risotto']
}

let [main, , secondary] = restaurant.categories

const [starter, mainCourse] = restaurant.order(1, 2)
console.log(starter, mainCourse) // <b>可以用来拆分函数返回数组，实现对多个数据的同时输出</b>
</samp>
交换变量数据[main, secondary] = [secondary, main]

const [a = 1, b] = [9, 2]

</details>
</details>
<details><summary>2. 对象</summary>
<samp>
	// 自定义变量名:
	const {name: restaurantName,
	openingHrs: openHrs,
	categories: tags} = restaurant

	// const {name, openingHrs, categories} = restaurant // 和数组一样，直接对应属性取对应值
	
	const {name: restaurantName,
	openingHrs: openHrs,
	categories: tags} = restaurant
	
	// <b>设定初始值</b>
	// const { menu = [], starterMenu: starters = [] } = restaurant
	// console.log(menu, starters)
	
	let a = 170
	let b = 89
	const obj = {a: 23, b: 2, c: 1};
	// {a, b} = obj // js会把每行开头的{}识别成代码块，所以报错
	({a, b} = obj); // 可以
	// 用括号上下文要加分号，否则报错
	
	
	// <b>object嵌套</b>
	// const {fri} = openHrs // fri 取openHrs.fri
	
	// 取fri 里面的值
	const {fri: {open, close}} = openHrs // {object: {a, b,...}}
	// console.log(fri) // fri 没有定义
	console.log(open, close)
	
	
	restaurant.orderDelivery = function ({starterIndex, mainIndex, address, time = '20:00'}) { // 输入拆分的object, 如果没有这一项用初始值, 如果没有初始值undefined (看time)
		console.log(`Orders recieved! ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivers to ${address} at ${time}. `)
	}
	
	restaurant.orderDelivery(
	{time: '22:30', address: '1', mainIndex: 2, starterIndex: 2}
	)
</samp>
</details>

</details>

<details open><summary>运算符</summary>
<details><summary>the Spread Operator / 展开操作符</summary>
	// The Spread Operator 展开运算符 (...)
	const arr = [1,2,3]
	const newArr_w = [1, 2, 3, arr[0], arr[1], arr[2]]
	// es6之后
	const newArr = [1, 2, ...arr]
	console.log(newArr)
	// ... 将数组每一项都分别提出来
	console.log(...newArr) // 1, 2, 1, 2, 3
	
	restaurant.newMenu = [...restaurant.mainMenu, 'Gnocci']
	console.log(restaurant.newMenu)
	
	// 怎么用
	
	// 复制
	const mainMenuCopy = [...	restaurant.mainMenu]
	// 整合
	const menu = [...restaurant.starterMenu, ...restaurant.mainMenu]
	
	// 适用于字符串, array, map, set 等，object在2018后开始支持
	
	// 在字符串中使用
	const str = '请尽快上线'
	const characters = [...str]
	console.log(characters)
	
	// 在函数中应用
	restaurant.orderPasta = function(...ingredients) {
		return arguments // 有, 的地方可以用... 但${}里面不能用
	}
	const ingredients = ['a', 'b', 'c']
	console.log(restaurant.orderPasta(ingredients))
	
	// 在object中使用
	const restaurantCopy = {...restaurant}
	
	restaurantCopy.name = 'Ristorante Roma'
	console.log(restaurantCopy)
	console.log(restaurant)
	// 这样复制后改object里面的属性 不会影响之前的object.
</details>
<details><summary>The Rest Operator</summary>
	// 展开，因为在=右边。
	const arr = [1, 2, ...[3, 4]]
	
	// 从右边数组取数据，
	const [a, b, ...others] = [1,2,3,4,5]
	console.log(others) // Array(3) [ 3, 4, 5 ]
	// 收集剩余的项再重组到新的数组
	
	// const [c, d, ...oothers, what] = [1,2,3,4,5]
	// console.log(oothers) // Uncaught SyntaxError: rest element may not have a trailing comma
	// <b>只能是最后的</b>
	
	
	const [pizza, , resotto, ...otherFood] = [...restaurant.mainMenu, ...restaurant.starterMenu]
	console.log(otherFood)
	
	// objects
	const {sat, ...weekdays} = restaurant.openingHrs // object 不分先后
	console.log(weekdays)
	
	// 传多个值到函数
	const add = function(...numbers) {
		console.log(numbers)
		
		let sum = 0
		for(let i=0; i&lt;numbers.length;i++) sum += numbers[i]
		console.log(sum)
		return sum
	} // 不限制数量
	add(2, 3)
	add(2, 3, 1, 2, 3)
</details>
<details><summary>短路运算? short circuiting</summary>


<b>||: 从头开始，如果找到非false值就返回这个值</b>
如果都没有返回最后一个值

<samp>
console.log(3 || 'Hello') // 或运算符 => 3
console.log('' || '1') // '1'
console.log(0 || true) // true

const guests1 = restaurant.numGuests ? restaurant.numGuests : 10 // undefined 和 undefined 或 是false
console.log(guests1)
  
// 用这个特性
const guests2 = restaurant.numGuests || 10
</samp>

<b>&&: 找到第一个false的值并返回</b>
如果都没有返回最后一个值

<samp>
console.log(0 && 'hello') // 0
console.log('hello' && 0) // 0
console.log('hello' && 7) // 7

if (restaurant.orderPizza) { // 如果这个存在就运行
	console.log(restaurant.orderPizza)
}
// 可以简化成：
restaurant.orderPizza && restaurant.orderPizza()

/* 如果orderPizza不存在则跳过
   如果orderPizza存在则运行后面的 orderPizza()*/
</samp>
</details>
<details><summary>The Nullish Coalescing Operator / 空值合并运算符 (??)</summary>
和 || 差不多，但
<samp>
// restaurant.numGuests = 0
// const guests = restaurant.numGuests || 10 // 10
// 把上2行注释后
const guests = restaurant.numGuests || 10 // 10

console.log(guests)

// Nullish: null, undefined (NOT 0 or '')
const guestsCorrect = restaurant.numGuests ?? 10 // 10

// 将两行注释恢复：
const guestsCorrect = restaurant.numGuests ?? 10 // 0
console.log(guestsCorrect)
// 修复了当0或''时字符串判断错误的问题
</samp>

</details>
<details><summary>Logical Assignment Operator / 逻辑赋值运算符</summary>

<b>||=</b>

<samp>
const rest1 = {
	name: 'capri',
	numGuests: 20
}
const rest2 = {
	name: 'La Piazza',
	owner: 'Ginovanni'
}
</samp>
rest1.numGuests ||= 10
和这个相同：rest1.numGuests = rest1.numGuests || 10
类似于a = a + b ==> a+=b

<b>其他同理</b>
&&= ??=
</details>
<details><summary>案例</summary>
<samp>
/*
Suppose we get data from a web service about a certain game (below). In this challenge we're gonna work with the data. So here are your tasks:
1. Create one player array for each team (variables 'players1' and 'players2') ✅
2. The first player in any player array is the goalkeeper and the others are field players. For Bayern Munich (team 1) create one variable ('gk') with the goalkeeper's name, and one array ('fieldPlayers') with all the remaining 10 field players ✅
3. Create an array 'allPlayers' containing all players of both teams (22 players) ✅
4. During the game, Bayern Munich (team 1) used 3 substitute players. So create a new array ('players1Final') containing all the original team1 players plus 'Thiago', 'Coutinho' and 'Perisic' ✅
5. Based on the game.odds object, create one variable for each odd (called 'team1', 'draw' and 'team2')  ✅
6. Write a function ('printGoals') that receives an arbitrary number of player names (NOT an array) and prints each of them to the console, along with the number of goals that were scored in total (number of player names passed in)
7. The team with the lower odd is more likely to win. Print to the console which team is more likely to win, WITHOUT using an if/else statement or the ternary operator.
TEST DATA FOR 6: Use players 'Davies', 'Muller', 'Lewandowski' and 'Kimmich'. Then, call the function again with players from game.scored
*/

const game = {
  team1: 'Bayern Munich',
  team2: 'Borrussia Dortmund',
  players: [
    [
      'Neuer',
      'Pavard',
      'Martinez',
      'Alaba',
      'Davies',
      'Kimmich',
      'Goretzka',
      'Coman',
      'Muller',
      'Gnarby',
      'Lewandowski',
    ],
    [
      'Burki',
      'Schulz',
      'Hummels',
      'Akanji',
      'Hakimi',
      'Weigl',
      'Witsel',
      'Hazard',
      'Brandt',
      'Sancho',
      'Gotze',
    ],
  ],
  score: '3:0',
  scored: ['Lewandowski', 'Gnarby', 'Lewandowski'],
  date: 'Nov 9th, 2037',
  odds: {
    team1: 1.33,
    x: 3.25,
    team2: 6.5,
  },
};

const [players1, players2] = [...game.players]

const [gk1, ...fieldPlayers1] = players1

const allPlayers = [...players1, ...players2]

const players1Final = [...players1, 'Thiago', 'Coutinho', 'Perisic']

const {team1, x: draw, team2} = game.odds
console.log(team1, draw, team2)

const printGoals = (...scoredPlayers) => {
	for (let i=0; i&lt;scoredPlayers.length; i++) {
		// let
	}
	console.log(`${scoredPlayers.length} were scored`)
}

printGoals('Lewandowski', 'Gnarby', 'Lewandowski')
console.log(`${(team1 &lt; team2 || 'team2') && 'team1'} is more likely to win.`)
等于team1 &lt; team2 && 
team1 > team2 &&
</samp>
</details>

<details><summary>Optional Chaining / 可选链运算符</summary>
// 检索周一是否营业
if (restaurant.openingHrs.mon) console.log(restaurant.openingHrs.mon.open)
// 但如果openingHrs也没有，继续访问mon会报错

// optional chaining 可选链运算符
// 逻辑：如果有这个子属性就继续往下读
//       如果没有返回undefined
console.log(restaurant.openingHrs.mon?.open)

<b>用例</b>
const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']
for (const day of days) {
  // 每天的营业状态
  // const open = openingHrs[day]?.open || 'closed'
  // saturday 为特例，open时间为0被短路到'closed'
  // 这时用 ??
  const open = openingHrs[day]?.open ?? 'closed'
  console.log(`On ${day}, we open at ${open}`)
}

// ?. 在<b>Methods</b> (对象中的函数)
console.log(restaurant.order?.(0,1) ?? 'Method does not exist.')

// Arrays
const users =[{name: 'Admin', email:{'hello@git-scm.com'}}]
console.log(users[0]?.name ?? 'User array empty') // 访问到undefined
</details>
</details>
<details><summary>用于数组的循环 for..of</summary>
const menu = [...restaurant.starterMenu, ...restaurant.mainMenu]
for (const item of menu) console.log(item)
// 列出列表中的每一项

for (const [i, el] of menu.entries()) document.write(`${i + 1}, ${el}`)
// entries() 返回[]

</details>
<details><summary>es6 对象语法增强</summary>

<b>以前</b>
order: function (starterIndex, mainIndex) {
    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]]
},

<b>现在</b>
order(starterIndex, mainIndex) {
    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]]
},

<b>以前</b>
{
  a: b
  openingHrs: openingHrs
}

<b>现在</b>
{
  a: b
  openingHrs,
}

</details>


<samp>
    const restaurant = {
        name: 'Classico Italiano',
        location: ',,, Firenze, Italy',
        categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],


        starterMenu: [
          'Focaccia',
          'Bruschetta',
          'Garlic Bread',
          'Caprese Salad',
        ],
        mainMenu: ['Pizza', 'Pasta', 'Risotto'],

        order: function (starterIndex, mainIndex) {
          return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]]
        },

        openingHrs: {
          thu: {
            open: 12,
            close: 22
          },
          fri: {
            open: 11,
            close: 23
          },
          sat: {
            open: 0,
            close: 24
          }
        }
		
      }
</samp>

</details>

</details>



</body>
</html>
