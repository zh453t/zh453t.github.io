<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="lib/public.css">
	<style title="contries">
		
		* {
			/* margin: 0; */
			/* padding: 0; */
			box-sizing: inherit;
		}

		html {
			box-sizing: border-box;
		}

		body {
			font-family: system-ui;
			color: #555;
			background-color: #f7f7f7;
			min-height: 100vh;
			position: relative;

			/* display: flex;
			align-items: center;
			justify-content: center; */
		}

		.container {
			display: flex;
			flex-flow: column;
			align-items: center;
			white-space:normal;
			font-size: 67.5%;
		}

		.countries {
			margin-bottom: 8rem;
			display: flex;

			font-size: 2rem;
			opacity: 0;
			transition: opacity 1s;
		}

		.country {
			background-color: #fff;
			box-shadow: 0 2rem 5rem 1rem rgba(0, 0, 0, 0.1);
			font-size: 1.8rem;
			width: 30rem;
			border-radius: 0.7rem;
			margin: 0 3rem;
			/* overflow: hidden; */
		}

		.neighbour::before {
			content: 'Neighbour country';
			width: 100%;
			position: absolute;
			top: -4rem;

			text-align: center;
			font-size: 1.8rem;
			font-weight: 600;
			text-transform: uppercase;
			color: #888;
		}

		.neighbour {
			transform: scale(0.8) translateY(1rem);
			margin-left: 0;
		}

		.country__img {
			width: 30rem;
			height: 17rem;
			object-fit: cover;
			background-color: #eee;
			border-top-left-radius: 0.7rem;
			border-top-right-radius: 0.7rem;
		}

		.country__data {
			padding: 2.5rem 3.75rem 3rem 3.75rem;
		}

		.country__name {
			font-size: 2.7rem;
			margin-bottom: 0.7rem;
		}

		.country__region {
			font-size: 1.4rem;
			margin-bottom: 2.5rem;
			text-transform: uppercase;
			color: #888;
		}

		.country__row:not(:last-child) {
			margin-bottom: 1rem;
		}

		.country__row span {
			display: inline-block;
			margin-right: 2rem;
			font-size: 2.4rem;
		}

		.btn-country {
			border: none;
			padding: 1rem 2.5rem;
			border-radius: 0.7rem;
			color: white;
			background-color: orangered;
			cursor: pointer;
		}

		.images {
			display: flex;
		}

		.images img {
			display: block;
			width: 80rem;
			margin: 4rem;
		}

		.images img.parallel {
			width: 40rem;
			margin: 2rem;
			border: 3rem solid white;
			box-shadow: 0 2rem 5rem 1rem rgba(0, 0, 0, 0.1);
		}

		.popup {
			min-width: 20em;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			padding: 1em 2em;

			#closePopup {
				padding: 0.2em 1em;
				margin-block: 0 0.5em
			}

			#errorText {
				font-weight: bold;
				color: darkred;
				font-size: large;
			}
		}

	</style>
	
	<title>async</title>
	<script src="lib/async.js" defer></script>
</head>

<body>
	<main class="container">
		<div class="countries">
			<!--
			<article class="country">
				<img class="country__img" src="" />
				<div class="country__data">
					<h3 class="country__name">COUNTRY</h3>
					<h4 class="country__region">REGION</h4>
					<p class="country__row"><span>👫</span>POP people</p>
					<p class="country__row"><span>🗣️</span>LANG</p>
					<p class="country__row"><span>💰</span>CUR</p>
				</div>
			</article>
			-->
		</div>
		<button class="btn-country">Where am I?</button>
		<div class="images"></div>
	</main>
	<dialog class="popup">
		<button id="closePopup">X</button>
		<p id="errorText"></p>
</dialog>
<hr>
<h3>AJaX</h3>
Asynchronous Javascript & XML
XML 现在谁还用啊

Ajax 最吸引人的特性是它的“异步”性质，这意味着它可以与服务器通信、交换数据并更新页面，而无需刷新页面。

<b>创建：</b>
传统方法：
const httpRequest = new XMLHttpRequest();
httpRequest.open(&lt;Method: string (例：GET, POST, FETCH), URL: string>)
httpRequest.addEventListener('load', function() {
	// 
})

什么年代了还在XMLHttpRequest?

const request = fetch(URL: string) 2015年的东西a
返回一个 <a href="#promise">Promise</a>


<h4>Async: Asynchronous</h4>
a-synchronous: not synchronous
不同步的
同步：按照代码的顺序

setTimeout()
有些 eventListener
和服务器沟通都是异步的
下面的代码会首先执行，当条件满足=时代码自动执行

怎么让这些按顺序执行？
setTimeout(() => {
	setTimeout(() => {
		setTimeout(() => {
			setTimeout(() => {

			}, 1000)
		}, 1000)
	}, 1000)
}, 1000)
回调地狱

怎么摆脱？
<b id="promise">Promise</b>
2014年的东西

fetch() 会创建一个 Promise
之后：
Promise.prototype.then(onSuccess, onFail)
Promise 实例的 then() 方法最多接受两个参数：用于 Promise 兑现和拒绝情况的回调函数。它立即返回一个等效的 Promise 对象，允许你链接到其他 Promise 方法，从而实现链式调用。
不用你手动写 return

特别： fetch() 的 Promise 返回的内容需要 json()
  -> Response.json()
	-> <b>它返回一个 Promise</b>，Promise 的解析 resolve 结果是将文本体解析为 JSON。

所以 fetch(url).then(request => request.json()).then(requestData => {

})

<h4>出错怎么办</h4>
<b>记得</b>在最后加上 .catch()
Promise.prototype.then(err => {

})

<h4>403 404这些怎么办</h4>
在request.json() 那里加上
if (!request) <b>throw</b> new Error(errorText: string)
 -> throw 语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw 之后的语句将不会执行）
 -> Error() 和任何一个对象构造器 (object constructor) 一样，传入的是新错误的文本


<h2>创建 Promise</h2>
new Promise(executor(resolve: function, reject: function): function)

const lotteryPromise = new Promise(function(resolve<i>: function</i>, reject<i>: function</i>) {
	if(Math.random() >= 0.5) resolve(resolvedValue<i>: string</i>)
})

resolve() 把 Promise 的状态设成 fulfilled
resolve(resolvedValue)
 -> 返回 resolvedValue ，传入 then()

 lotteryPromise.then(result => console.log(result))


<h2>async function 和 await</h2>
2017年的东西
是 Promise.then().then().then().then().then()
await 操作符用于等待一个 Promise 兑现并获取它兑现之后的值。它只能在异步函数或者模块顶层中使用。

异步函数：
被调用后，<b>永远</b>返回一个 Promise, 函数正常的返回值（用 return 语句写的那个）是 Promise 的 fulfilledValue

并行： <b>Promise.all()</b>
Promise() 的静态方法
Promise.all(iterable)
Promise.all() 接收一个数组，返回一个数组
但是， 只要一个 Promise 出现错误(或者被拒绝?)， all()就立即结束执行， 短路

<b>Promise.race()</b>
比赛：谁先敲定/兑现(settled)返回谁的值
也会短路，和上面一样

Promise.allSettled()
2020年的东西
和 Promise.all() 差不多
但是无论 Promise 是否 resolved (兑现)，都会返回结果

Promise.any()
将 [Promise1, Promise2, Promise3... ] 作为输入，并返回一个 Promise。
当输入的任何一个 Promise 兑现时，这个返回的 Promise 将会兑现，并返回第一个兑现的值。当所有输入 Promise 都被拒绝（包括传递了空的可迭代对象）时，它会以一个包含拒绝原因数组的 AggregateError 拒绝。

异步的要await!!!
<h1>try ... catch</h1>
查错机制
2004之前的东西
</body>
</html>