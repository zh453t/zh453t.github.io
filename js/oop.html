<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<title>D</title>
	<link rel="stylesheet" href="lib/public.css">
	<!-- <script defer src="lib/public.js"></script> -->
</head>
<body>
通常的oop:
class -> object
class 类似于这样：
<samp>User {
	name
	password
	email
	login()
	logout()
	closeAccount()
}</samp>
不存在真实的数据，而是根据这种模式，通过某种方法创建对象


js 中没有 Classes
而是 prototype &lt;- object
任何一个 function, array, object 等，都可以调用共同的方法，像 array 都有 map() forEach() 等
而这些原型都有其独有的构造函数：
像 Array(), Object(), Set(), Map() 这些，
想要调用这些构造函数，必须用 new 运算符
<samp>new Array('123')</samp>
这些构造函数都有一个特征，就是首字母大写，这也是约定俗成的

怎样创建一个构造函数呢？
<samp>const Person = function(firstName, birthYear) {
}
new Person('JP', 1970)</samp>
构造函数看似和普通函数没有区别，但是 new 赋予他一个过程：
1. 新的 {} 被创建
2. 函数被调用，this = {}
3. this({}) 与原(prototype)型连接
4. 函数自动返回 this({})

在函数内，可以修改this
<samp>	this.firstName = firstName
	this.birthYear = birthYear</samp>
在 Chrome 中会显示 Person {...}
在 Firefox 中还是显示 Object {...}, 点开之后才会看到<samp>&lt;prototype>: Object { … }
	constructor: function Person(firstName, birthYear)</samp>
不要在构造函数中加方法 (methods)！不然原型是干什么的

<h2>Prototype: 原型</h2>
每个对象都有其原型。
Array.prototype
这是一个 object
Array.__proto__ 因为Array是个构造函数，所以这是一个函数

所以：
<samp>Person.prototype.isPrototypeOf(Person) // false
	Person.prototype === JP.__proto__ // true
	Person 的 .prototype 不是 Person 的 Prototype
	其实 .prototype 应该被叫做 .prototypeOfLinkedObjects
	Person.prototype 是被构造对象继承的原型 (Prototype)
</samp>构造的任何对象都会继承原型的方法，属性等

检测是否为自己的属性：object.hasOwnProperty(PropertyName: string)
<samp>const print = console.info
const Person = function(firstName, birthYear) {
	this.firstName = firstName
	this.birthYear = birthYear

	// dont do this
	/*this.calcAge = function() {
		print(2037 - this.birthYear)
	}*/
}
let JP = new Person('JP', 2012)
JP.calcAge = 1

Person.prototype.calcAge = function() {
	print(2037 - this.birthYear)
}


print(JP.__proto__.__proto__)
</samp><samp>const Car = function (make, speed) {
	this.make = make
	this.speed = speed
}
Car.prototype.accelerate = function() {this.speed += 10}
Car.prototype.break = function() {this.speed -= 5}
const bmw = new Car('BMW', 120)
bmw.accelerate()
bmw.break()
console.info(bmw)
</samp>

<h2>Class</h2>
语法糖
<ol><li>类没有被提升</li><li>Classes are first-class citizens</li></ol>
这么写：<samp>class PersonCl {
	constructor(firstName, birthYear) {
		this.firstName = firstName
		this.birthYear = birthYear
	}
	calcAge() {
		console.log(2037-this.birthYear)
	}
// 其实这里就是定义原型里的方法
}
const jessica = new PersonCl('Jessica', 1996)</samp>


<h2>Setter 和 Getter</h2>
在对象中，
const account = {
	owner: 'jonas',
	movements: [200,100,5,10],
	<b>get</b> latest() {
		return this.movements.slice(-1).pop()
	}
}
访问此函数时，可以 account.latest
account.hasOwnProperty('latest') // true


Setter
当尝试设置属性时，set 语法将对象属性绑定到要调用的函数。它还可以在类中应用。
{ set prop(val) { /* … */ } }
{ set [expression](val) { /* … */ } }
prop
	要绑定到给定函数的属性名。
val
	用于保存尝试分配给prop的值的变量的一个别名，传入函数的

通常会创建一个伪属性，以_开头

<h4>静态方法</h4>
构造函数独有
Array.from()
不能在任何一个数组 [1,2,3] 上使用这个方法

<h5>创建：</h5>
1. 构造函数
Person.[fnName] = function() {}

2. 在类中
// 静态方法：
static hey() {
	<div class="marquee"><p>hello</p></div>
}
<samp>class PersonCl {
	constructor(fullName, birthYear) {
		this.fullName = fullName
		this.birthYear = birthYear
	}
	age() {
		console.log(2037-this.birthYear)
	}
	set fullName(name) {
		console.log(name)
		if (name.includes(' ')) this._fullName = name
		else alert(`${name} is not a full name`)
	}
	get fullName() {return this._fullName}


}
const jessica = new PersonCl('Jessica Davis', 1996)
// const walter = new PersonCl('Walter', 1919)


const account = {
	owner: 'jonas',
	movements: [200,100,5,10],
	get latest() {
		return this.movements[this.movements.length-1]
	},
	set newOwner(owner) {
		console.log(new String(this.owner))
		// this.owner.push(`, ${owner}`)
	}

}
console.log(account.hasOwnProperty('latest'))

account.newOwner = 'JP'</samp>

<h4>Object.create</h4>
Object.create(prototype: object)
会返回一个空对象，和给定的原型绑定
<samp>const PersonPrototype = {
	calcAge() {
		console.log(2037-this.birthYear)
	},
	init(firstName, birthYear) {
		this.firstName = firstName
		this.birthYear = birthYear
	}
}
const steven = Object.create(PersonPrototype)
// steven.birthYear = 2002
// steven.calcAge()
steven.init('Steven', 2002)
</samp><samp>
class Car {
	constructor(make, speed) {
		this.make = make
		this.speed = speed
		// in km/h
	}
	get speedUS() {
		return this.speed / 1.6
		// in mi/h
	}
	acclerate() {this.speed += 10}
	break() {this.speed -= 5}

	set speedUS(speed) {
		this.speed = speed * 1.6
	}

}
const ford = new Car('Ford', 120)
ford.speedUS = 100
// 同一个 speedUS 用 getter 读取， setter 设
print(ford)</samp>

手动原型链
<samp>
	Person.prototype.hi = function() {print(hi)}
	const Student = function(firstName, birthYear, course) {
	Person.call(this, firstName, birthYear)
	this.course = course
}

const mike = new Student('Mike', 2020, 'Biology')
Student.prototype = Object.create(Person.prototype)
print(Student.prototype)
Student.prototype.introduce = function() {
	console.info(`My name is ${this.firstName}, and I study ${this.course}`)
}

print(mike)

// 用 Object.create 实现原型链继承
// 可是 js 认为 Student.prototype.constructor 是 Person()
// Student.prototype.constructor = Student
print(Student.prototype.constructor)
mike.introduce()
mike.hi()</samp>
<samp>const Car = function (make, speed) {
	this.make = make
	this.speed = speed
}
Car.prototype.accelerate = function() {this.speed += 10}
Car.prototype.break = function() {this.speed -= 5}

const EV = function(make, speed, charge) {
	Car.call(this, make, speed)
	this.charge = charge
}

EV.prototype = Object.create(Car.prototype)

EV.prototype.chargeBattery = function(chargeTo) {
	this.charge = chargeTo
	console.info(`${this.make} charged to ${this.charge}`)
}

EV.prototype.accelerate = function() {
	this.speed += 20
	this.charge--
	console.info(`${this.make} going at ${this.speed}km/h, with a charge of ${this.charge}%`)
}	

const tesla = new EV('Tesla', 120, 23)
tesla.accelerate()
tesla.chargeBattery(90)
tesla.accelerate()</samp>

用 Class :
<samp>class Person {
	constructor(fullName, birthYear) {
		this.fullName = fullName
		this.birthYear = birthYear
	}
	age() {
		console.log(2037-this.birthYear)
	}
	set fullName(name) {
		console.log(name)
		if (name.includes(' ')) this._fullName = name
		else alert(`${name} is not a full name`)
	}
	get fullName() {return this._fullName}
}

class Student extends Person {
	constructor(fullName, birthYear, course) {
		// 一定最先发生 
		super(fullName, birthYear)
		this.course = course
	}
	introduce() {return 'hi'}
}

const martha = new Student('Martha Jones', 2012, 'Politics')
console.log('1')
print(martha.introduce())</samp>

<h3>私有域</h3>
#
<samp>// Public fields
// Private fields
class Account {
	// Public field 不是 prototype
	locale = navigator.language;
	
	
	// Private field
	#movements = [];
	#pin;

	constructor(owner, currency, pin) {
		this.owner = owner
		this.currency = currency
		
		this.#pin = pin
		// this.movements = []
		// this.locale = navigator.language
		console.info(`Thanks for opening an account, ${this.owner}`)
	}

	// 下面的方法会被加入 prototype
	// Public methods

	getMovements() {
		return this.#movements
	}
	
 	deposit(val) {
		this.#movements.push(val)
		return this
	}

	withdraw(val) {
		this.#movements.push(-val)
		return this
	}

	
	requestLoan(val) {
		if (this.#approveLoan(val)) {
			this.deposit(val)
			console.info('Loan Approved')
		} else console.info('Loan Invalid')
		return this
	}
	
	#approveLoan(val) {
		return true
	}

	// 静态方法：只是这个 Class 
	static helper() {
		console.info('Hello')
	}


}
const acc1 = new Account('Jonas', 'EUR', 1111)

// acc1.#movements.push(250) //Uncaught SyntaxError: reference to undeclared private field or method #movements
// 像 pin 和 approveLoan() 这些不应该被外界直接访问
acc1.requestLoan(215)
print(acc1)
Account.helper()

// Chaining
acc1.deposit(300).deposit(300)</samp>
<script>
'use strict'
print = console.dir
class Car {
	constructor(make, speed) {
		this.make = make
		this.speed = speed
		// in km/h
	}
	get speedUS() {
		return this.speed / 1.6
		// in mi/h
	}
	acclerate() {this.speed += 10}
	break() {this.speed -= 5}

	set speedUS(speed) {
		this.speed = speed * 1.6
	}

}

class EV extends Car {
	#charge
	constructor(make, speed, charge) {
		super(make, speed)
		this.#charge = charge
	}
	chargeBattery(chargeTo) {this.charge = chargeTo}
	acclerate() {this.speed += 10; this.#charge -= 5}
}
const rivian = new EV('Rivian', 120, 23)
print(rivian)
</script>	
</body>
</html>