<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="UTF-8">
	<title>DOM</title>
	<link rel="stylesheet" href="lib/public.css">
</head>

<body>
	<details name="det" what="you">
		<summary>选择元素：</summary>
		querySelector()
		*选择一个元素
		*普遍适用
		可以用 document.querySelector(),
		也可以用 element.querySelector() 从其子元素中选择
		所以可以 document.querySelector('details').querySelector('summary')

		querySelectorAll()
		同上
		*返回nodeList，静态的

		<b name="det">返回所有元素</b>
		document.getElementById()
		getElementsByClassName()
		getElementsByTagName()
		getElementsByName() &lt;= 这个选择name=""
		*只能document, 元素没有此功能。
		*返回<b>动态</b>列表
		在chrome上解析成LiveHTMLCollection
		在firefox上还是NodeList


		<b>父子关系</b>
		element.parentElement
		element.childElement
	</details>
	<details>
		<summary>元素增删</summary>
		document.createElement()
		这个只会返回一个新建的元素，而且不会应用到现有的html中。
		通常需要存到变量中。

		<b>在dom中插入元素</b>
		<samp><b>before()</b>
			&lt;sample>
			prepend()
			append()
			&lt;/sample>
			<b>after()</b></samp>一个节点只能在dom中出现一次

		<b>复制元素</b>
		cloneNode(boolean)
		如果传入true, 节点的子节点将会一起复制

		<b>删除元素</b>
		element.remove()
		element.removeChild()
	</details>
	<details>
		<summary>元素操作</summary>
		<h3>元素内：</h3>
		textContent 可删可读 getter/setter


		innerHTML 可删可读，全部的HTML，包括元素
		innerText
		HTMLElement 接口的 innerText 属性表示一个节点及其后代所渲染文本的内容。
		<b>无论</b>元素是否被渲染，Node.textContent返回所有文字元素
		element.innerText<b>只</b>返回被渲染的文字

		<h3>class: 类</h3>
		element.classList
		一个DOMTokenList, 可由如下操作
		.add()
		.remove()
		.replace()
		.replace(old, new)
		*如果成功，返回true, 如果没有找到old, 返回false
		.toggle()

		<h3>样式 / style</h3>
		element.style
		可删可读 只能访问inline-style

		getComputedStyles(element)
		CSS2Properties(369) {...}
		会把元素显示在网页上的css全部列出，包括默认值和计算后的宽高等

		设置： element.setProperty(StyleName:string, StyleValue:string)

		--开头的是变量

		<h3>attibute</h3>
		element.[attribute]
		style也是attribute
		只能是原生的attribute, 自己造的不支持

		getAttribute()
		setAttribute()
		能获取和创建自定义元素
	</details>
	<details>
		<summary>对象: DOMRect</summary>
		元素显示时的矩形
		Rectangle: 矩形
		{
		x, y, --- 原点的x, y坐标
		bottom, 底坐标值（通常与 y + height 具有相同的值，如果 height 为负值，则为 y 的值）。
		left, 左坐标值（通常与 x 具有相同的值，如果 width 为负值，则为 x + width 的值）。
		top, 顶坐标值（通常与 y 具有相同的值，如果 height 为负值，则为 y + height 的值）。
		right, 右坐标值（通常与 x + width 具有相同的值，如果width 为负值，则为 x 的值）。
		width, height, --- 宽高
		}

		静态方法：DOMRectReadOnly.fromRect() 创建一个DOMRect


		getBoundingClientRect()
		返回该元素的DOMRect

		getClientRects()
		Element.getClientRects() 方法返回一个指向客户端中每一个盒子的边界矩形的矩形集合。


		滚动功能：
		现在滚动到了哪里？
		window.scrollX
		window.scrollY
		其实可以省略window

		1: window.<b>scrollTo()</b>
		window.scrollTo(x-coord,y-coord) 或
		window.scrollTo(options)
		x-coord 是文档中的横轴坐标。
		y-coord 是文档中的纵轴坐标。
		options 是一个包含三个属性的对象：
    	top 等同于 y-coord
    	left 等同于 x-coord
    	behavior 类型 String，表示滚动行为，支持参数 smooth(平滑滚动),instant(瞬间滚动),默认值 auto

		element 也有 scrollTo()
		Element 的 scrollTo() 方法可以使界面滚动到给定元素的指定坐标位置。



		浏览器窗口高度和长度：
		document.documentElement.cilentHeight
		document.documentElement.cilentWidth

		怎么滚动？
		window.scrollTo
	</details>
	<details id="e">
		<summary>事件</summary>
		是什么？
		Event 接口表示在 DOM 中出现的事件。

		一些事件是由用户触发的，例如鼠标或键盘事件；或者由 API 生成以表示异步任务的进度。事件也可以通过编程方式触发，例如对元素调用 HTMLElement.click() 方法，或者定义一些自定义事件，再使用
		EventTarget.dispatchEvent() 方法将自定义事件派发往指定的目标（target）。

		监听：addEventListener(事件名称<sup>1</sup>, 执行的函数(事件<sup><b>*</b></sup>)<sup>2</sup>, 捕获还是冒泡<sup>3</sup>)
		<b>*</b>: 事件是一个对象，可以访问的属性有：
		event.type 事件名称，如click, keyDown
		<sup>3</sup>: true 是捕获, false(默认)是冒泡

		移除：removeEventListener()

		阻止默认行为发生(像表单按Enter提交，锚链接点击跳转等)：
		event.preventDefult()
		这也是event这个对象里的方法之一

		mouseenter 和 mouseover 不可冒泡
		mouseover 和 mouseout 可以冒泡

		DOMContentLoaded 是整个 html 文件下载完成，(不包括引用的文件)，DOM树建立
		load 是所有外部资源都下载完成

		当浏览器窗口关闭或者刷新时，会触发 beforeunload 事件。当前页面不会直接关闭，可以点击确定按钮关闭或刷新，也可以取消关闭或刷新。

		> .
		| |
		| |
		| |
		| |
		|_|
		<h3>冒泡：</h3><style>
			#a {
				width: 300px;
				height: 300px;
			}

			#b {
				width: 200px;
				height: 200px;
			}

			#c {
				width: 100px;
				height: 100px;
			}

			#a,
			#b,
			#c {
				border: 3px darkturquoise solid;
				cursor: pointer;
				background-color: #fff;
			}
		</style><div id="a"><div id="b"><div id="c"></div></div></div><script>// 冒泡：
			const box1 = document.getElementById('a')
			const box2 = document.getElementById('b')
			const box3 = document.getElementById('c')

			const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1) + min)

			const randomColor = () => `rgb(${randomInt(0, 255)}, ${randomInt(0, 255)}, ${randomInt(0, 255)})`

			const eventRC = function (event) {
				this.style.backgroundColor = randomColor()
			}
			a.addEventListener('click', eventRC, true)
			b.addEventListener('click', eventRC, true)
			c.addEventListener('click', eventRC, true)</script>
		点击小方块，大方块的颜色也会变化
		在addEventListener中执行event.stopPropagation()会阻止这种情况发生。
		EventListener在默认情况下从冒泡阶段
		
	</details>
	<details><summary>遍历</summary>
		element.querySelector{All}()

		element.childNodes 包括文字的所有元素
		element.children 是HTMLCollection, 不包含文字
		只有一层

		同样：
		element.parentElement
		element.parentNode

		closest()
		传入和 querySelector() 一样的字符串，会向上找到与元素最近的元素， querySelector 是向下

		nextElementSibling
		previousElementSibling


	</details>

	<hr>
	<details><summary>Intersection Observer API</summary>
	创建: new IntersectionObserver(callbackFn, options)
	callbackFn: 回调函数，在 observer 第一次观察时和 (观察的元素, root)交叉部分满足阙值时被调用
	options: 一个 object
	{
		root: document.querySelector('#scrollArea'), <ins>=> root 元素, 可选，默认为窗口，设置成 null 也是窗口</ins>
  	rootMargin: '0px', <ins>=> 触发时被观察元素与 root 元素的距离, 相当于css的margin</ins>
  	threshold: 1.0 <ins>=> 阙值, 重合的大小，可以设成数组，含多个阙值，触发 callbackFn</ins>
	}

	observer 会向 callbackFn 传入这些参数：
		entries: 一个数组, 包含所有 entry (有几个阙值就有几个 entry)
			entry: 一个对象，包含...

	</details>
	<script src="lib/public.js"></script>
	<script>
		'use strict';
		const det = document.getElementsByName('det')
		console.log(document.querySelector('details').querySelector('summary').textContent)

		const e = document.getElementById('e')
		const fun = (event) => {
			console.log('Oh Shit')
			e.removeEventListener('mouseenter', fun)
		}
		e.addEventListener('mouseenter', fun)

		console.log(e.getClientRects())
		
	</script>
</body>

</html>